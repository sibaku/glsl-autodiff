
//********************************************************************
//
// Global defines
//
//********************************************************************

// Infinity
#define AUTO_INFINITY 3.402823e+38


//********************************************************************
//
// General functions
//
//********************************************************************

mat2 a_outerProduct(in vec2 a, in vec2 b)
{
	return mat2(a * b.x, a * b.y);
}

mat3 a_outerProduct(in vec3 a, in vec3 b)
{
	return mat3(a * b.x, a * b.y, a * b.z);
}

mat4 a_outerProduct(in vec4 a, in vec4 b)
{
	return mat4(a * b.x, a * b.y, a * b.z, a * b.w);
}

//********************************************************************
//
// Data structure for holding information for 2D Gradient calculation.
//
//********************************************************************

struct GradNum2
{
	float val;
	vec2 g;
};

//********************************************************************
//
// Data structure for holding information for 3D Gradient calculation
//
//********************************************************************

struct GradNum3
{
	float val;
	vec3 g;
};

//********************************************************************
//
// Data structure for holding information for 4D Gradient calculation
//
//********************************************************************

struct GradNum4
{
	float val;
	vec4 g;
};

//********************************************************************
//
// Data structure for holding information for 2D Hessian calculation. Gradient is also included
//
//********************************************************************


struct HessNum2
{
	float val;
	vec2 g;
	mat2 h;
};

//********************************************************************
//
// Data structure for holding information for 3D Hessian calculation. Gradient is also included
//
//********************************************************************


struct HessNum3
{
	float val;
	vec3 g;
	mat3 h;
};

//********************************************************************
//
// Data structure for holding information for 4D Hessian calculation. Gradient is also included
//
//********************************************************************


struct HessNum4
{
	float val;
	vec4 g;
	mat4 h;
};




//********************************************************************
//
// 2D Gradient functions
//
//********************************************************************


GradNum2 a_constG2(in float val)
{
	return GradNum2(val, vec2(0.));
}

GradNum2 neg(in GradNum2 a)
{
	return GradNum2(-a.val,-a.g);
}

GradNum2 add(in GradNum2 a, in GradNum2 b)
{
	return GradNum2(a.val + b.val, a.g + b.g);
}

GradNum2 add(in GradNum2 a, in float b)
{
	return GradNum2(a.val + b, a.g);
}

GradNum2 add(in float a, in GradNum2 b)
{
	return GradNum2(b.val + a, b.g);
}

GradNum2 sub(in GradNum2 a, in GradNum2 b)
{
	return GradNum2(a.val - b.val, a.g - b.g);
}

GradNum2 sub(in GradNum2 a, in float b)
{
	return GradNum2(a.val - b, a.g);
}

GradNum2 sub(in float a, in GradNum2 b)
{
	return GradNum2(a - b.val, -b.g);
}

GradNum2 mult(in GradNum2 a, in GradNum2 b)
{
	return GradNum2(a.val * b.val, b.val*a.g + a.val*b.g);
}

GradNum2 mult(in GradNum2 a, float b)
{
	return GradNum2(a.val*b, a.g*b);
}

GradNum2 mult(in float a, in GradNum2 b)
{
	return GradNum2(b.val*a, b.g*a);
}

GradNum2 div(in GradNum2 a, in GradNum2 b)
{
	GradNum2 r = GradNum2(a.val / b.val, a.g);
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;
	return r;
}

GradNum2 div(in GradNum2 a, float b)
{
	return GradNum2(a.val/b, a.g/b);
}

GradNum2 div(float a, in GradNum2 b)
{
	return div(a_constG2(a), b);
}

GradNum2 a_sin(in GradNum2 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum2(s , c * a.g);
}

GradNum2 a_cos(in GradNum2 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum2(c , -s * a.g);
}

GradNum2 a_exp(in GradNum2 a)
{
	float e = exp(a.val);
	return GradNum2(e , e * a.g);
}

GradNum2 a_log(in GradNum2 a)
{
	float ai = 1./a.val;
	return GradNum2(log(a.val) , ai * a.g);
}

GradNum2 a_pow(in GradNum2 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return GradNum2(pow(a.val,k) , ap * a.g);
}

GradNum2 a_abs(in GradNum2 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	return GradNum2(l , lp * a.g);
}

GradNum2 a_sqrt(in GradNum2 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	return GradNum2(as,a.g*asd);
}


//********************************************************************
//
// 3D Gradient functions
//
//********************************************************************


GradNum3 a_constG3(in float val)
{
	return GradNum3(val, vec3(0.));
}

GradNum3 neg(in GradNum3 a)
{
	return GradNum3(-a.val,-a.g);
}

GradNum3 add(in GradNum3 a, in GradNum3 b)
{
	return GradNum3(a.val + b.val, a.g + b.g);
}

GradNum3 add(in GradNum3 a, in float b)
{
	return GradNum3(a.val + b, a.g);
}

GradNum3 add(in float a, in GradNum3 b)
{
	return GradNum3(b.val + a, b.g);
}

GradNum3 sub(in GradNum3 a, in GradNum3 b)
{
	return GradNum3(a.val - b.val, a.g - b.g);
}

GradNum3 sub(in GradNum3 a, in float b)
{
	return GradNum3(a.val - b, a.g);
}

GradNum3 sub(in float a, in GradNum3 b)
{
	return GradNum3(a - b.val, -b.g);
}

GradNum3 mult(in GradNum3 a, in GradNum3 b)
{
	return GradNum3(a.val * b.val, b.val*a.g + a.val*b.g);
}

GradNum3 mult(in GradNum3 a, float b)
{
	return GradNum3(a.val*b, a.g*b);
}

GradNum3 mult(in float a, in GradNum3 b)
{
	return GradNum3(b.val*a, b.g*a);
}

GradNum3 div(in GradNum3 a, in GradNum3 b)
{
	GradNum3 r = GradNum3(a.val / b.val, a.g);
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;

	return r;
}

GradNum3 div(in GradNum3 a, float b)
{
	return GradNum3(a.val/b, a.g/b);
}

GradNum3 div(float a, in GradNum3 b)
{
	return div(a_constG3(a), b);
}

GradNum3 a_sin(in GradNum3 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum3(s , c * a.g);
}

GradNum3 a_cos(in GradNum3 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum3(c , -s * a.g);
}

GradNum3 a_exp(in GradNum3 a)
{
	float e = exp(a.val);
	return GradNum3(e , e * a.g);
}

GradNum3 a_log(in GradNum3 a)
{
	float ai = 1./a.val;
	return GradNum3(log(a.val) , ai * a.g);
}

GradNum3 a_pow(in GradNum3 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return GradNum3(pow(a.val,k) , ap * a.g);
}

GradNum3 a_abs(in GradNum3 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	return GradNum3(l , lp * a.g);
}

GradNum3 a_sqrt(in GradNum3 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	return GradNum3(as,a.g*asd);
}


//********************************************************************
//
// 4D Gradient functions
//
//********************************************************************


GradNum4 a_constG4(in float val)
{
	return GradNum4(val, vec4(0.));
}

GradNum4 neg(in GradNum4 a)
{
	return GradNum4(-a.val,-a.g);
}

GradNum4 add(in GradNum4 a, in GradNum4 b)
{
	return GradNum4(a.val + b.val, a.g + b.g);
}

GradNum4 add(in GradNum4 a, in float b)
{
	return GradNum4(a.val + b, a.g);
}

GradNum4 add(in float a, in GradNum4 b)
{
	return GradNum4(b.val + a, b.g);
}

GradNum4 sub(in GradNum4 a, in GradNum4 b)
{
	return GradNum4(a.val - b.val, a.g - b.g);
}

GradNum4 sub(in GradNum4 a, in float b)
{
	return GradNum4(a.val - b, a.g);
}

GradNum4 sub(in float a, in GradNum4 b)
{
	return GradNum4(a - b.val, -b.g);
}

GradNum4 mult(in GradNum4 a, in GradNum4 b)
{
	return GradNum4(a.val * b.val, b.val*a.g + a.val*b.g);
}

GradNum4 mult(in GradNum4 a, float b)
{
	return GradNum4(a.val*b, a.g*b);
}

GradNum4 mult(in float a, in GradNum4 b)
{
	return GradNum4(b.val*a, b.g*a);
}

GradNum4 div(in GradNum4 a, in GradNum4 b)
{
	GradNum4 r = GradNum4(a.val / b.val, a.g);
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;
	return r;
}

GradNum4 div(in GradNum4 a, float b)
{
	return GradNum4(a.val/b, a.g/b);
}

GradNum4 div(float a, in GradNum4 b)
{
	return div(a_constG4(a), b);
}

GradNum4 a_sin(in GradNum4 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum4(s , c * a.g);
}

GradNum4 a_cos(in GradNum4 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return GradNum4(c , -s * a.g);
}

GradNum4 a_exp(in GradNum4 a)
{
	float e = exp(a.val);
	return GradNum4(e , e * a.g);
}

GradNum4 a_log(in GradNum4 a)
{
	float ai = 1./a.val;
	return GradNum4(log(a.val) , ai * a.g);
}

GradNum4 a_pow(in GradNum4 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return GradNum4(pow(a.val,k) , ap * a.g);
}

GradNum4 a_abs(in GradNum4 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	return GradNum4(l , lp * a.g);
}

GradNum4 a_sqrt(in GradNum4 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	return GradNum4(as,a.g*asd);
}


//********************************************************************
//
// 2D Hessian functions
//
//********************************************************************


HessNum2 a_constH2(in float val)
{
	return HessNum2(val, vec2(0.), mat2(0.));
}

HessNum2 neg(in HessNum2 a)
{
	return HessNum2(-a.val,-a.g,-a.h);
}

HessNum2 add(in HessNum2 a, in HessNum2 b)
{
	return HessNum2(a.val + b.val, a.g + b.g, a.h + b.h);
}

HessNum2 add(in HessNum2 a, in float b)
{
	return HessNum2(a.val + b, a.g , a.h);
}

HessNum2 add(in float a, in HessNum2 b)
{
	return HessNum2(b.val + a, b.g , b.h);
}

HessNum2 sub(in HessNum2 a, in HessNum2 b)
{
	return HessNum2(a.val - b.val, a.g - b.g, a.h - b.h);
}

HessNum2 sub(in HessNum2 a, in float b)
{
	return HessNum2(a.val - b, a.g , a.h);
}

HessNum2 sub(in float a, in HessNum2 b)
{
	return HessNum2(a - b.val, -b.g , -b.h);
}

HessNum2 mult(in HessNum2 a, in HessNum2 b)
{
	return HessNum2(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));
}

HessNum2 mult(in HessNum2 a, float b)
{
	return HessNum2(a.val*b, a.g*b, a.h*b);
}

HessNum2 mult(in float a, in HessNum2 b)
{
	return HessNum2(b.val*a, b.g*a, b.h*a);
}

HessNum2 div(in HessNum2 a, in HessNum2 b)
{
	HessNum2 r = HessNum2(a.val / b.val, a.g, a.h );
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;

	r.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);
	r.h = r.h / b.val;

	return r;

}

HessNum2 div(in HessNum2 a, float b)
{
	return HessNum2(a.val/b, a.g/b, a.h/b);
}

HessNum2 div(float a, in HessNum2 b) {
	return div(a_constH2(a), b);
}

HessNum2 a_sin(in HessNum2 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum2(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));
}

HessNum2 a_cos(in HessNum2 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum2(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));
}

HessNum2 a_exp(in HessNum2 a)
{
	float e = exp(a.val);
	return HessNum2(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));
}

HessNum2 a_log(in HessNum2 a)
{
	float ai = 1./a.val;
	return HessNum2(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));
}

HessNum2 a_pow(in HessNum2 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return HessNum2(pow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*pow(a.val,k-2.) * a_outerProduct(a.g,a.g));
}

HessNum2 a_abs(in HessNum2 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	// Probably better to always make this 0
	float lpp = a.val == 0. ? AUTO_INFINITY : 0.;
	return HessNum2(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));
}

HessNum2 a_sqrt(in HessNum2 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	float asdd = -1./(4.*pow(a.val,3./2.));
	return HessNum2(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));
}

//********************************************************************
//
// 3D Hessian functions
//
//********************************************************************


HessNum3 a_constH3(in float val)
{
	return HessNum3(val, vec3(0.), mat3(0.));
}

HessNum3 neg(in HessNum3 a)
{
	return HessNum3(-a.val,-a.g,-a.h);
}

HessNum3 add(in HessNum3 a, in HessNum3 b)
{
	return HessNum3(a.val + b.val, a.g + b.g, a.h + b.h);
}

HessNum3 add(in HessNum3 a, in float b)
{
	return HessNum3(a.val + b, a.g , a.h);
}

HessNum3 add(in float a, in HessNum3 b)
{
	return HessNum3(b.val + a, b.g , b.h);
}

HessNum3 sub(in HessNum3 a, in HessNum3 b)
{
	return HessNum3(a.val - b.val, a.g - b.g, a.h - b.h);
}

HessNum3 sub(in HessNum3 a, in float b)
{
	return HessNum3(a.val - b, a.g , a.h);
}

HessNum3 sub(in float a, in HessNum3 b)
{
	return HessNum3(a - b.val, -b.g , -b.h);
}

HessNum3 mult(in HessNum3 a, in HessNum3 b)
{
	return HessNum3(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));
}

HessNum3 mult(in HessNum3 a, float b)
{
	return HessNum3(a.val*b, a.g*b, a.h*b);
}

HessNum3 mult(in float a, in HessNum3 b)
{
	return HessNum3(b.val*a, b.g*a, b.h*a);
}

HessNum3 div(in HessNum3 a, in HessNum3 b)
{
	HessNum3 r = HessNum3(a.val / b.val, a.g, a.h );
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;

	r.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);
	r.h = r.h / b.val;

	return r;
}

HessNum3 div(in HessNum3 a, float b)
{
	return HessNum3(a.val/b, a.g/b, a.h/b);
}

HessNum3 div(float a, in HessNum3 b) {
	return div(a_constH3(a), b);
}

HessNum3 a_sin(in HessNum3 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum3(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));
}

HessNum3 a_cos(in HessNum3 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum3(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));
}

HessNum3 a_exp(in HessNum3 a)
{
	float e = exp(a.val);
	return HessNum3(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));
}

HessNum3 a_log(in HessNum3 a)
{
	float ai = 1./a.val;
	return HessNum3(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));
}

HessNum3 a_pow(in HessNum3 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return HessNum3(pow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*pow(a.val,k-2.) * a_outerProduct(a.g,a.g));
}

HessNum3 a_abs(in HessNum3 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	// Probably better to always make this 0
	float lpp = a.val == 0. ? AUTO_INFINITY : 0.;
	return HessNum3(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));
}

HessNum3 a_sqrt(in HessNum3 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	float asdd = -1./(4.*pow(a.val,3./2.));
	return HessNum3(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));
}

//********************************************************************
//
// 4D Hessian functions
//
//********************************************************************


HessNum4 a_constH4(in float val)
{
	return HessNum4(val, vec4(0.), mat4(0.));
}

HessNum4 neg(in HessNum4 a)
{
	return HessNum4(-a.val,-a.g,-a.h);
}

HessNum4 add(in HessNum4 a, in HessNum4 b)
{
	return HessNum4(a.val + b.val, a.g + b.g, a.h + b.h);
}

HessNum4 add(in HessNum4 a, in float b)
{
	return HessNum4(a.val + b, a.g , a.h);
}

HessNum4 add(in float a, in HessNum4 b)
{
	return HessNum4(b.val + a, b.g , b.h);
}

HessNum4 sub(in HessNum4 a, in HessNum4 b)
{
	return HessNum4(a.val - b.val, a.g - b.g, a.h - b.h);
}

HessNum4 sub(in HessNum4 a, in float b)
{
	return HessNum4(a.val - b, a.g , a.h);
}

HessNum4 sub(in float a, in HessNum4 b)
{
	return HessNum4(a - b.val, -b.g , -b.h);
}

HessNum4 mult(in HessNum4 a, in HessNum4 b)
{
	return HessNum4(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));
}

HessNum4 mult(in HessNum4 a, float b)
{
	return HessNum4(a.val*b, a.g*b, a.h*b);
}

HessNum4 mult(in float a, in HessNum4 b)
{
	return HessNum4(b.val*a, b.g*a, b.h*a);
}

HessNum4 div(in HessNum4 a, in HessNum4 b)
{
	HessNum4 r = HessNum4(a.val / b.val, a.g, a.h );
	r.g = r.g - r.val*b.g;
	r.g = r.g / b.val;

	r.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);
	r.h = r.h / b.val;

	return r;
}

HessNum4 div(in HessNum4 a, float b)
{
	return HessNum4(a.val/b, a.g/b, a.h/b);
}

HessNum4 div(float a, in HessNum4 b) {
	return div(a_constH4(a), b);
}

HessNum4 a_sin(in HessNum4 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum4(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));
}

HessNum4 a_cos(in HessNum4 a)
{
	float c = cos(a.val);
	float s = sin(a.val);
	return HessNum4(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));
}

HessNum4 a_exp(in HessNum4 a)
{
	float e = exp(a.val);
	return HessNum4(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));

}

HessNum4 a_log(in HessNum4 a)
{
	float ai = 1./a.val;
	return HessNum4(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));

}

HessNum4 a_pow(in HessNum4 a, float k)
{
	float ap = k*pow(a.val,k-1.);
	return HessNum4(pow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*pow(a.val,k-2.) * a_outerProduct(a.g,a.g));

}

HessNum4 a_abs(in HessNum4 a)
{
	float l = abs(a.val);
	float lp = sign(a.val);
	// Probably better to always make this 0
	float lpp = a.val == 0. ? AUTO_INFINITY : 0.;
	return HessNum4(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));

}

HessNum4 a_sqrt(in HessNum4 a)
{
	float as = sqrt(a.val);
	float asd = 1. / (2.*as);
	float asdd = -1./(4.*pow(a.val,3./2.));
	return HessNum4(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g));
}

//********************************************************************
//
// First derivative accumulation is stored in vec2 per parameter
//
//********************************************************************

vec2 a_const(in float val)
{
    return vec2(val,0.);
}

vec2 neg(in vec2 u)
{
	return -u;
}

vec2 add(in vec2 u, in vec2 v)
{
 	return u + v ;
}

vec2 add(in vec2 u, in float v)
{
 	return vec2(u.x + v,u.y) ;
}

vec2 add(in float u, in vec2 v)
{
 	return vec2(u + v.x,v.y) ;
}

vec2 sub(in vec2 u, in vec2 v)
{
 	return u - v;
}

vec2 sub(in vec2 u, in float v)
{
 	return vec2(u.x - v,u.y);
}

vec2 sub(in float u, in vec2 v)
{
 	return vec2(u - v.x,-v.y);
}

vec2 mult(in vec2 u, in vec2 v)
{
 	return vec2(u.x*v.x, u.y*v.x + v.y*u.x);
}

vec2 mult(in vec2 u, in float v)
{
	return v*u;
}

vec2 mult(in float u, in vec2 v)
{
	return u*v;
}

vec2 div(in vec2 u, in vec2 v)
{
 	return vec2(u.x / v.x, (u.y*v.x - v.y*u.x)/(v.x*v.x));
}

vec2 div(in vec2 u, in float v)
{
 	return u / v;
}

vec2 div(in float u, in vec2 v) {
	return u / v;
}

vec2 a_sin(in vec2 u)
{
    return vec2(sin(u.x),u.y * cos(u.x));
}

vec2 a_cos(in vec2 u)
{
 	return vec2(cos(u.x),-u.y*sin(u.x));
}

vec2 a_exp(in vec2 u)
{
 	vec2 r = vec2(exp(u.x));
    r.y *= u.y;
    return r;
}

vec2 a_log(in vec2 u)
{
    return vec2(log(u.x),u.y/u.x);
}

vec2 a_pow(in vec2 u,in float k)
{
    return vec2(pow(u.x,k),k*pow(u.x,k-1.)*u.y);
}

vec2 a_abs(in vec2 u)
{
    return vec2(abs(u.x),sign(u.x)*u.y);
}

vec2 a_sqrt(in vec2 u)
{
	float us = sqrt(u.x);
	return vec2(us,u.y/(2.*us));
}


//********************************************************************
//
// Second derivative accumulation is stored in vec3 per parameter
//
//********************************************************************

vec3 a_const2D(in float val)
{
	return vec3(val,0.,0.);
}

vec3 add(in vec3 u, in vec3 v)
{
	return u + v;
}

vec3 add(in vec3 u, in float v)
{
	return vec3(u.x + v, u.y, u.z);
}

vec3 add(in float u, in vec3 v)
{
	return vec3(u+v.x, v.y,v.z);
}

vec3 neg(in vec3 u)
{
	return -u;
}

vec3 sub(in vec3 u, in vec3 v)
{
	return u - v;
}

vec3 sub(in vec3 u, in float v)
{
	return vec3(u.x - v, u.y, u.z);
}

vec3 sub(in float u, in vec3 v)
{
	return vec3(u - v.x, - v.y, -v.z);
}

vec3 mult(in vec3 u, in vec3 v)
{
	return vec3(u.x*v.x, u.y*v.x + v.y*u.x, u.z*v.x + 2.*u.y*v.y + u.x * v.z);
}

vec3 mult(in vec3 u, in float v)
{
	return u*v;
}

vec3 mult(in float u, in vec3 v)
{
	return u*v;
}

vec3 div(in vec3 u, in vec3 v)
{
 	return vec3(u.x / v.x, (u.y*v.x - v.y*u.x)/(v.x*v.x),(v.x*v.x*u.z - v.x*(2.*u.y*v.y + u.x*v.z) + 2.*u.x*v.y*v.y)/(v.x*v.x*v.x));
}

vec3 div(in vec3 u, in float v)
{
	return u / v;
}

vec3 div(in float u, in vec3 v) {
	return u / v;
}

vec3 a_sin(in vec3 u)
{
    return vec3(sin(u.x),u.y * cos(u.x),u.z*cos(u.x) - u.y*u.y*sin(u.x));
}

vec3 a_cos(in vec3 u)
{
 	return vec3(cos(u.x),-u.y*sin(u.x),-u.y*u.y*cos(u.x) - u.z*sin(u.x));
}

vec3 a_exp(in vec3 u)
{
 	vec3 r = vec3(exp(u.x));
    r.y *= u.y;
	r.z *= (u.z + u.y*u.y);
    return r;
}
vec3 a_log(in vec3 u)
{
    return vec3(log(u.x),u.y/u.x,(u.x*u.z - u.y*u.y)/(u.x*u.x));
}

vec3 a_pow(in vec3 u,in float k)
{
    return vec3(pow(u.x,k),k*pow(u.x,k-1.)*u.y,k*pow(u.x,k-2.)*((k-1.)*u.y*u.y + u.x*u.z));
}

vec3 a_abs(in vec3 u)
{
	// Probably best to just ignore special case
    return vec3(abs(u.x),sign(u.x)*u.y,sign(u.x)*u.z + (u.x !=0. ? 0. : 2.*AUTO_INFINITY*u.y*u.y));
}

vec3 a_sqrt(in vec3 u)
{
	float us = sqrt(u.x);
	return vec3(us,u.y/(2.*us),(2.*u.x*u.z - u.y*u.y)/(4.*pow(u.x,3./2.)));
}


//********************************************************************
//
// Convenience defines for gradients and jacobians
//
//********************************************************************


//********************************************************************
//
// GradNum based gradients
//
//********************************************************************
#define GRAD2(f,u,v,result) {result = f(GradNum2(u,vec2(1.,0.)),GradNum2(v,vec2(0.,1.)));}


#define GRAD3(f,u,v,w,result) {result = f(GradNum3(u,vec3(1.,0.,0.)),GradNum3(v,vec3(0.,1.,0.)),GradNum3(w,vec3(0.,0.,1.)));}


#define GRAD4(f,u,v,w,x,result) {result = f(GradNum4(u,vec4(1.,0.,0.,0.)),GradNum4(v,vec4(0.,1.,0.,0.)),GradNum4(w,vec4(0.,0.,1.,0.)),GradNum4(x,vec4(0.,0.,0.,1.)));}


//********************************************************************
//
// vec2 based gradients
//
//********************************************************************

#define GRAD2_v(f,u,v,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.);result = vec2(f(uGrad,vGrad).y,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  result.y = f(uGrad,vGrad).y;}

#define GRAD3_v(f,u,v,w,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);result = vec3(f(uGrad,vGrad,wGrad).y,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.); result.y = f(uGrad,vGrad,wGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.); result.z = f(uGrad,vGrad,wGrad).y;}

#define GRAD4_v(f,u,v,w,x,result) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.);result = vec4(f(uGrad,vGrad,wGrad,xGrad).y,0.,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.); result.y = f(uGrad,vGrad,wGrad,xGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.);vec2 xGrad = vec2(x,0.); result.z = f(uGrad,vGrad,wGrad,xGrad).y;vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,1.); result.w = f(uGrad,vGrad,wGrad,xGrad).y;}

#define GRAD2_VALUE_v(f,u,v,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); grad = f(uGrad,vGrad).yx; value = grad.y; uGrad = vec2(u,0.); vGrad = vec2(v,1.);  grad.y = f(uGrad,vGrad).y;}

#define GRAD3_VALUE_v(f,u,v,w,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.); vec2 r_w_value = f(uGrad,vGrad,wGrad);value = r_w_value.x; grad = vec3(r_w_value.y,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.); grad.y = f(uGrad,vGrad,wGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.); grad.z = f(uGrad,vGrad,wGrad).y;}

#define GRAD4_VALUE_v(f,u,v,w,x,grad,value) { vec2 uGrad = vec2(u,1.); vec2 vGrad = vec2(v,0.); vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.);vec2 r_w_value = f(uGrad,vGrad,wGrad,xGrad);value = r_w_value.x; grad = vec4(r_w_value.y,0.,0.,0.); uGrad = vec2(u,0.); vGrad = vec2(v,1.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,0.); grad.y = f(uGrad,vGrad,wGrad,xGrad).y;uGrad = vec2(u,0.); vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,1.);vec2 xGrad = vec2(x,0.); grad.z = f(uGrad,vGrad,wGrad,xGrad).y;vGrad = vec2(v,0.);  vec2 wGrad = vec2(w,0.);vec2 xGrad = vec2(x,1.); grad.w = f(uGrad,vGrad,wGrad,xGrad).y;}

//********************************************************************
//
// Jacobians for vec2 based gradients
//
//********************************************************************
// Without result
#define JACOBI2_v(f1,f2,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; }

#define JACOBI3_v(f1,f2,f3,u,v,w,result) { vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z;}

#define JACOBI4_v(f1,f2,f3,f4,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w; GRAD4_v(f4,u,v,w,x,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z; result[3][3] = gradResult.w;}

#define JACOBI23_v(f1,f2,u,v,w,result) {vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; }

#define JACOBI24_v(f1,f2,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w;}

#define JACOBI32_v(f1,f2,f3,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; }

#define JACOBI34_v(f1,f2,f3,u,v,w,x,result) { vec4 gradResult = vec4(0.); GRAD4_v(f1,u,v,w,x,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w;}

#define JACOBI42_v(f1,f2,f3,f4,u,v,result) { vec2 gradResult = vec2(0.); GRAD2_v(f1,u,v,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; vec2 gradResult = vec2(0.); GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; GRAD2_v(f4,u,v,gradResult); result[3][1] = gradResult.x;result[3][1] = gradResult.y;}

#define JACOBI43_v(f1,f2,f3,f4,u,v,w,result) { vec3 gradResult = vec3(0.); GRAD3_v(f1,u,v,w,gradResult); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; GRAD3_v(f4,u,v,w,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z;}

// With result
#define JACOBI2_VALUE_v(f1,f2,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; }

#define JACOBI3_VALUE_v(f1,f2,f3,u,v,w,result,value) { vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z;}

#define JACOBI4_VALUE_v(f1,f2,f3,f4,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w; GRAD4_v(f4,u,v,w,x,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z; result[3][3] = gradResult.w;}

#define JACOBI23_VALUE_v(f1,f2,u,v,w,result,value) {vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; }

#define JACOBI24_VALUE_v(f1,f2,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w;}

#define JACOBI32_VALUE_v(f1,f2,f3,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; }

#define JACOBI34_VALUE_v(f1,f2,f3,u,v,w,x,result,value) { vec4 gradResult = vec4(0.); GRAD4_VALUE_v(f1,u,v,w,x,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; result[3][0] = gradResult.w; GRAD4_v(f2,u,v,w,x,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; result[3][1] = gradResult.w; GRAD4_v(f3,u,v,w,x,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; result[3][2] = gradResult.w;}

#define JACOBI42_VALUE_v(f1,f2,f3,f4,u,v,result,value) { vec2 gradResult = vec2(0.); GRAD2_VALUE_v(f1,u,v,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y; GRAD2_v(f2,u,v,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y; vec2 gradResult = vec2(0.); GRAD2_v(f3,u,v,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y; GRAD2_v(f4,u,v,gradResult); result[3][1] = gradResult.x;result[3][1] = gradResult.y;}

#define JACOBI43_VALUE_v(f1,f2,f3,f4,u,v,w,result,value) { vec3 gradResult = vec3(0.); GRAD3_VALUE_v(f1,u,v,w,gradResult,value); result[0][0] = gradResult.x;result[1][0] = gradResult.y;result[2][0] = gradResult.z; GRAD3_v(f2,u,v,w,gradResult); result[0][1] = gradResult.x;result[1][1] = gradResult.y;result[2][1] = gradResult.z; GRAD3_v(f3,u,v,w,gradResult); result[0][2] = gradResult.x;result[1][2] = gradResult.y;result[2][2] = gradResult.z; GRAD3_v(f4,u,v,w,gradResult); result[0][3] = gradResult.x;result[1][3] = gradResult.y;result[2][3] = gradResult.z;}

//********************************************************************
//
// Jacobians for GradNum based gradients
//
//********************************************************************
// Without result
#define JACOBI2(f1,f2,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; }

#define JACOBI3(f1,f2,f3,u,v,w,result) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z;}

#define JACOBI4(f1,f2,f3,f4,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w; GRAD4(f4,u,v,w,x,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z; result[3][3] = gradResult.g.w;}

#define JACOBI23(f1,f2,u,v,w,result) {GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; }

#define JACOBI24(f1,f2,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w;}

#define JACOBI32(f1,f2,f3,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; }

#define JACOBI34(f1,f2,f3,u,v,w,x,result) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w;}

#define JACOBI42(f1,f2,f3,f4,u,v,result) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; vec2 gradResult.g = vec2(0.); GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; GRAD2(f4,u,v,gradResult); result[3][1] = gradResult.g.x;result[3][1] = gradResult.g.y;}

#define JACOBI43(f1,f2,f3,f4,u,v,w,result) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; GRAD3(f4,u,v,w,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z;}

// With result
#define JACOBI2_VALUE(f1,f2,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; }

#define JACOBI3_VALUE(f1,f2,f3,u,v,w,result,value) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z;}

#define JACOBI4_VALUE(f1,f2,f3,f4,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult.g,value); value = gradResult.val;  result[0][0] = gradResult.g.x; result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w; GRAD4(f4,u,v,w,x,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z; result[3][3] = gradResult.g.w;}

#define JACOBI23_VALUE(f1,f2,u,v,w,result,value) {GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; }

#define JACOBI24_VALUE(f1,f2,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult);  value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w;}

#define JACOBI32_VALUE(f1,f2,f3,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value = gradResult.val; result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; }

#define JACOBI34_VALUE(f1,f2,f3,u,v,w,x,result,value) { GradNum4 gradResult; GRAD4(f1,u,v,w,x,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; result[3][0] = gradResult.g.w; GRAD4(f2,u,v,w,x,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; result[3][1] = gradResult.g.w; GRAD4(f3,u,v,w,x,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; result[3][2] = gradResult.g.w;}

#define JACOBI42_VALUE(f1,f2,f3,f4,u,v,result,value) { GradNum2 gradResult; GRAD2(f1,u,v,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y; GRAD2(f2,u,v,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y; vec2 gradResult.g = vec2(0.); GRAD2(f3,u,v,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y; GRAD2(f4,u,v,gradResult); result[3][1] = gradResult.g.x;result[3][1] = gradResult.g.y;}

#define JACOBI43_VALUE(f1,f2,f3,f4,u,v,w,result,value) { GradNum3 gradResult; GRAD3(f1,u,v,w,gradResult); value = gradResult.val;  result[0][0] = gradResult.g.x;result[1][0] = gradResult.g.y;result[2][0] = gradResult.g.z; GRAD3(f2,u,v,w,gradResult); result[0][1] = gradResult.g.x;result[1][1] = gradResult.g.y;result[2][1] = gradResult.g.z; GRAD3(f3,u,v,w,gradResult); result[0][2] = gradResult.g.x;result[1][2] = gradResult.g.y;result[2][2] = gradResult.g.z; GRAD3(f4,u,v,w,gradResult); result[0][3] = gradResult.g.x;result[1][3] = gradResult.g.y;result[2][3] = gradResult.g.z;}


//********************************************************************
//
// Hessians
//
//********************************************************************
#define HESSIAN2(f,u,v,result) { vec2 uGrad = vec2(1.,0.); HessNum2 uHessian = HessNum2(u,uGrad,mat2(0.)); vec2 vGrad = vec2(0.,1.); HessNum2 vHessian = HessNum2(v,vGrad,mat2(0.)); result = f(uHessian,vHessian);}

#define HESSIAN3(f,u,v,w,result) { vec3 uGrad = vec3(1.,0.,0.); HessNum3 uHessian = HessNum3(u,uGrad,mat3(0.)); vec3 vGrad = vec3(0.,1.,0.); HessNum3 vHessian = HessNum3(v,vGrad,mat3(0.)); vec3 wGrad = vec3(0.,0.,1.); HessNum3 wHessian = HessNum3(w,wGrad,mat3(0.)); result = f(uHessian,vHessian,wHessian);}

#define HESSIAN4(f,u,v,w,x,result) { vec4 uGrad = vec4(1.,0.,0.,0.); HessNum4 uHessian = HessNum4(u,uGrad,mat4(0.)); vec4 vGrad = vec4(0.,1.,0.,0.); HessNum4 vHessian = HessNum4(v,vGrad,mat4(0.)); vec4 wGrad = vec4(0.,0.,1.,0.); HessNum4 wHessian = HessNum4(w,wGrad,mat4(0.)); vec4 xGrad = vec4(0.,0.,1.,0.); HessNum4 xHessian = HessNum4(x,xGrad,mat4(0.)); result = f(uHessian,vHessian,wHessian,xHessian);}
